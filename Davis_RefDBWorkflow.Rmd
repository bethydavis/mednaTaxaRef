---
title: "Reference Database Creation for COI"
author: "Beth Davis"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This RMD is directly based on the work done by Dr. Erin Grey, specifically the file Erin_TestScript.R/RMD. Alterations are made solely for my personal ease of use and do not replace the work done by Erin, Ben Tupper, or the rest of the Maine-eDNA Reference Library Working Group.

This workflow utilizes a previously made species list to create a reference database by pulling sequences from NCBI GenBank. 

# Reference Database Creation

## Step R1: Read in config and set entrez key
```{r setup}
# Read in config
source("reflibconfig.R")

# Set entrez key
set_entrez_key(entrez_key)
```
The config handles package installation and loading, setting input and output files, and indirectly loading the entrez key. To use genbankr, use the tar.gz file in the repo and follow the instructions in reflibconfig as it must be installed and loaded manually.

## Step R2: Set search terms

The search term must be built in a specific format, and allows only certain options.

Enclose your chosen locus in "". The locus options are:

ATP6       ATP8        COI          COII        COIII          CYTB        ND1        ND2
ND3        ND4         ND4L         ND5         ND6          rRNA_12S     rRNA_16S    D_loop    
tRNA_Ala   tRNA_Arg    tRNA_Asn    tRNA_Asp    tRNA_Cys     tRNA_Gln      tRNA_Glu    tRNA_Gly
tRNA_His   tRNA_Ile    tRNA_Leu    tRNA_Lys    tRNA_Met     tRNA_Phe      tRNA_Pro    tRNA_Ser 
tRNA_Thr   tRNA_Trp    tRNA_Tyr    tRNA_Val

The mitogenome scrape also requires us to check if the target locus is a gene or a different feature
```{r search_term}
# Choose locus
locus = "COI"

# Check whether the locus is a gene or other feature
is_mtgene <- locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") 
```

AnnotationBustR has a list of synonyms for the loci options that we will reference, but if you know of synonyms that are not in the list, run the below chunk by adding the synonym in 'Name'. If you do not know of additional synonyms, skip this chunk.

```{r add_synonym}
# Check the AnnotationBustR list:
# data(mtDNAterms)

# Add additional synonyms
custom_synonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "") 

# Bind the additional synonyms back to the base list
mtDNAterms <- rbind(mtDNAterms, custom_synonyms) 
```


Now we set and format the rest of the search term
```{r complete_searchterm}
# Set synonyms for the target locus
target_locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,]

# Format for ENTREZ search terms by adding OR operator and TITL label
target_locus_synonyms$Terms <- paste0("OR ", target_locus_synonyms$Name, "[TITL]") 

# First term starts with "AND ("
target_locus_synonyms$Terms[1] <- paste0("AND (", target_locus_synonyms$Name[1], "[TITL]") 

# Last term ends with a ")"
target_locus_synonyms$Terms[dim(target_locus_synonyms)[1]] <- paste0("OR ", target_locus_synonyms$Name[dim(target_locus_synonyms)[1]], "[TITL])")

# The full ENTREZ search term
target_searchterm <- paste(as.vector(target_locus_synonyms$Terms), collapse=" ") 
```


## Step R3: Search for mitogenome and target sequences

This loop takes the input species list and the searchterm to query GenBank for mitogenomes and accession numbers, and adds identified ids to the specieslist object with the addition of columns n_mitogenome, ids_mitogenome, n_target, and ids_target

The loop will likely get stuck from an HTTP 500 error. If that happens, set i to whatever row number the error occurred on, and restart the loop
```{r accession_counter}
# Isolate the counter for sanity's sake (aka so you can change it without running the entire loop on accident if need be)
i = 1
```


This is the actual loop
```{r search_entrez}
while (i <= dim(specieslist)[1]){
  # Set a visual counter to display which row the script is on
  cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(specieslist)[1])
  # Define search terms for species
  #   Format species name by adding [ORGN]
  search_name <- paste0(specieslist$matched_name2[i],"[ORGN]")
  #   Combine search_name and target_searchterm to make the full search term
  search_term <- paste(search_name, target_searchterm, collapse=" ") 
  # Search ENTREZ for mitogenomes by adding additional search terms
   tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes
      if(class(mitogenomes)[1] != "try-catch") {
        #add mitogenome count to species list dataframe
        specieslist$n_mitogenome[i] <-mitogenomes$count[2] 
        #add mitogenome ids to species list dataframe
        specieslist$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") 
            # Search accession IDs and fill them into new columns
            tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets
                if(class(targets)[1] != "try-catch") {
                    specieslist$n_target[i] <-targets$count
                    specieslist$ids_target[i] <- paste(targets$ids, collapse="|")
                }
            }
  # Slow down request to the Entrez server or you'll get kicked out
  Sys.sleep(0.5) 
  
  # Reset loop variables
  mitogenomes <- "na"
  targets <- "na"
  search_name <- "na"
  search_term <- "na"
  i <- i + 1
}

beep(sound = "wilhelm")
```


With the loop finished, there are a few formatting steps to do before saving this interim output
```{r}
# Format the added columns to be numeric, and remove row numbers
specieslist$n_target <- as.numeric(specieslist$n_target) 
specieslist$n_mitogenome <- as.numeric(specieslist$n_mitogenome) 
row.names(specieslist) = NULL 

# Save output
write.csv(specieslist, file.path(path_outputs, "StepR3Output.csv"), row.names = FALSE)
```


## Step R4: DISCONTINUED - Scrape the target locus out of mitogenomes identified from Step 3

This loop takes the ids_mitogenome values found in Step R3 and, so long as there are at least 1, takes at most 20 mitogenomes, uses Genbank's information on the locus to scrape out the target range, and then appends to the interim_REFDB.

```{r mitogenome_counter}
# Set counter
m = 1
```

The actual loop
### NTS - not really working
```{r scrape_mitogenomes}
while (m <= dim(specieslist)[1]) { #for every good species name
    cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
    mito_ids <- "NA"
    #if mitogenomes available and <20
    if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { 
        #format ids
        mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) 
        #if >20 mitogenomes, subsample 20 mitogenomes randomly
    } else if (specieslist$n_mitogenome[m]>20) { 
        # format ids  
        mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) 
    }
    #if there are mitogenome ids for species m
    if (is.na(mito_ids[1]) == FALSE) { 
        #ask ENTREZ for id's accession
        mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) 
        #if no api error
        if (class(mito_accessions) != "try-catch"){ 
            #format accession numbers
            mito_accessions <- unlist(strsplit(mito_accessions, split="\n")) 
            # loop through and scrape each mitogenome accession
            for (n in 1:length(mito_accessions)){ 
              #blank row for each accession
              new_row <- c(paste("Unparsed mitochondrion", mito_accessions[n], sep=" "), "na", mito_accessions[n], "scrape", species=specieslist$matched_name2[m]) 
              # get the Genbank annotation for accession
              gb <- tryCatch(readGenBank(GBAccession(mito_accessions[n])))
                #if no error in getting gb
                if (class(gb) != "try-catch"){ 
                  # if target locus is not a gene, look in otherFeatures()
                  if (is_mtgene==FALSE) {
                  # find target locus annotation metadata 
                  target_feature <- tryCatch(which(otherFeatures(gb)$product %in% as.character(target_locus_synonyms$Name))) 
                    if (class(target_feature) != "try-catch"){
                      # if target feature is found
                      if(length(target_feature) > 0) { 
                        #extract the target range info
                        target_range <- tryCatch(otherFeatures(gb)@ranges[target_feature]) 
                          if(class(target_range) != "try-catch"){
                            #scrape seq
                            target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) 
                              if(class(target_seq) != "try-catch"){
                                #format
                                scraped_seq <- paste(target_seq)
                                #update information
                                new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) 
                            }
                          }
                      }
                    }
                  }
                  # if target locus is a gene, look in gene()
                  else if (is_mtgene==TRUE){ 
                    # find target locus annotation metadata 
                    target_feature <- tryCatch(which(genes(gb)$gene %in% as.character(target_locus_synonyms$Name))) 
                    if (class(target_feature) != "try-catch"){
                      # if target feature is found
                      if(length(target_feature) > 0) { 
                        #extract the target range info
                        target_range <- tryCatch(genes(gb)@ranges[target_feature])  
                          if(class(target_range) != "try-catch"){
                            #scrape seq
                            target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) 
                              if(class(target_seq) != "try-catch"){
                                #format
                                scraped_seq <- paste(target_seq) 
                                #update information
                                new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) 
                            }
                          }
                      }
                    }
                  }
                }
              # update the database
              interim_REFDB <- rbind(interim_REFDB, new_row) 
              # reset n loop variables
              rm(gb, target_feature, target_range, target_seq, scraped_seq, new_row) 
              # Slow request
              Sys.sleep(0.5) 
            } # close n loop (each "n" mitogenome accession per "m" species)
        }
    }
    #update species m variable
    m=m+1 
    # reset loop variables
    rm(mito_ids, mito_accessions) 
    #slow down request
    Sys.sleep(0.5) 
} # close for each species m loop
```

```{r}
interim_REFDB <- interim_REFDB[-1,] #format - remove the top row of NAs
interim_REFDB_unparsed <- subset(interim_REFDB, sequence == "na")
interim_REFDB_parsed <- subset(interim_REFDB, sequence != "na")
write.csv(interim_REFDB_parsed, file.path(path_outputs, "interim_REFDB.csv"), row.names=FALSE)
```

## Step R5: Scrape Accession Sequences

To scrape the accession sequences from our species list and add them to the interim_REFDB object, prep the loop with a counter and then run the loop

First create a skeleton for the interim_REFDB, and set a counter

```{r interim_creation}
# Create empty dataframe for sequence results to fill into
interim_REFDB <- data.frame(seq_header=NA, sequence=NA, seq_accession=NA, type=NA, species=NA) 
```

```{r accessions_counter}
s = 1
```

```{r scrape_accessions}
while (s <= dim(specieslist)[1]){ 
    # Display which species the script is on
    cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
    ids <- "na"
    seqs_target <- "na"
    # Scrape GenBank target sequences if available, but skip if >= 100 targets
    if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) { 
     ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
     # If more than 200 accessions, randomly select 100 
      } else if  (specieslist$n_target[s]>100) {    
     ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
      }
    # If there are accessions, fetch them from GenBank
    if (ids[1] !="na"){ 
        seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
        }
        if(class(seqs_target) != "try-catch"){
            if (seqs_target != "na"){
            # Format and write out the sequences
            write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta")))) 
            # Read the sequences back in as fasta files
            fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta") 
            # Get accession numbers
            seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc") 
            # Fix formatting of columns
            seq_header <- names(fasta_target) 
            sequence <- paste(fasta_target) 
            seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
            # Set lengths equal so any empty spaces will fill with NAs
            length(seq_header) <- length(sequence)
            length(seq_accession) <- length(sequence)
            # Make a temporary database with all sequences for the species, their header, accession number, etc.
            tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s]) 
            # Append temporary database to the full database
            interim_REFDB <- rbind(interim_REFDB, tempDB) 
                }
            s=s+1 # Advance counter, then reset loop variables
            }
    fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
    tempDB <-"na"
    # Slow request
    Sys.sleep(1)
}

beep(sound = "wilhelm")
```

Save this interim_REFDB, especially if you won't proceed to doing the missing order sampling
```{r save_interim}
write.csv(interim_REFDB, file.path(path_outputs, "interim_REFDB.csv"), row.names=FALSE)
```

## 5/18/2024 Scraping Note
For the GNRMaineSpecies_May2024, there were 19 rows that threw differing row number errors that couldn't be resolved. Investigation occurred via the following:

```{r}
# Make a vector of the row numbers that gave the error
troublemakers <- c(4573, 6588, 9018, 9883, 12854, 16494, 18879, 19250, 19428, 20037, 22838, 23106, 23234, 23912, 23989, 23991, 24061, 24224, 24492)

# Isolate the full rows from the specieslist corresponding to the numbers so I can investigate
troubledf <- specieslist[c(4573, 6588, 9018, 9883, 12854, 16494, 18879, 19250, 19428, 20037, 22838, 23106, 23234, 23912, 23989, 23991, 24061, 24224, 24492), ]
```

All rows that gave the error had only a single ids_target, with the exact same number, corresponding to a freshwater mitogenome survey of multiple taxa (https://www.ncbi.nlm.nih.gov/nuccore/1899214467). Given there were no other accession numbers found for these species, they can be added to the 'no references found' list.


# Gap Analysis (Optional but recommended)

It is highly unlikely that your species list will include representative species from every order, but having representatives of all orders can help with the accuracy of assigning taxonomy by providing outgroup comparison points. Additionally, it can be helpful to see where gaps are occurring with your primer's available reference library pool.

This process begins by finding the metazoan orders that present in the species list, getting a random set of max 3 mitogenome or accession numbers for species in those missing orders, and then repeating the scraping process that we did for our species list above.


## Step G1: Identify Missing Orders

First identify metazoan orders that aren't represented in the species list. The list of orders appends a code onto each row, so unless you check for matches while ignoring that code, it'll come back that no orders are present in the species list
```{r identify_missing}
# First pick out all unique orders from the species list
order_rep <- unique(specieslist$order, is.na = FALSE)
  # Convert the character list into a dataframe
order_repdf <- as.data.frame(order_rep)

# Separate the order name from the code
ordercompare <- orderlist %>% separate(order, c('Order', 'OrderCode'))

# Find the metazoan orders present in the orderlist but not in the species list
missingorders <- setdiff(ordercompare$Order, order_repdf$order_rep)

# Trim a new version of the orderlist with all columns but only the orders we're missing
orders_missing <- orderlist[grepl(paste(missingorders, collapse='|'), orderlist$order),]

# Save the list of missing orders (useful in case you're using the same species list for multiple primers)
write.csv(orders_missing, file.path(path_outputs, "StepG1Output.csv"), row.names=FALSE)

# Also create an empty dataframe for order_seqs, which is what the representatives of the missing orders will fill their sequences into
order_seqs <- as.data.frame(matrix(nrow=1, ncol=8, dimnames=list(NULL, c("superkingdom", "kingdom", "phylum", "class", "order", "species_id", "ids_mitogenome","ids_target"))))
```


## Step G2: Random Sampling of Missing Orders

This loop is very similar to Step R3, but limits the number of results to a random sampling of 3 mitogenomes or accession numbers. It adds the columns ids_mitogenomes and ids_target to the order_seqs object

Note that this step does require that you have done Step R2 to create the search term.

Like Step R3, it is possible that an HTTP 500 error will occur while it runs. If that happens, set the counter to the order number it crashed on and start the loop again.


Prepare the loop by setting the counter
```{r missingorder_counter}
o = 1
```


This is the actual loop
```{r missing_orders_seqs}

# Iterate through every missing order
while (o <= dim(orders_missing)[1]) { 
    # Display a counter of which number the script is on
    cat("\r", "finding ref seqs for order", o, "of", dim(orders_missing)[1]) 
    # set STOPIT equal to no as a default, and set to search as long as STOPIT = NO
    STOPIT <- "NO" 
    while (STOPIT == "NO"){ 
        # Refer to the species IDs for the missing order, given from the original orderlist
        species_ids_ls <- strsplit(orders_missing$spp_list[[o]], ";")
        # If there are no Genbank species for the order, set STOPIT to YES and stop searching for it
        if (is.na(species_ids_ls[[1]][1])) {STOPIT <- "YES"} 
        # Since we only want a max of 3 IDs, search for less than or equal to 3 
        if (length(species_ids_ls[[1]])<=3) { 
            # Format the species IDs
            species_ids <- species_ids_ls[[1]] 
            # For each species, add on additional qualifiers for the search term
            for (j in 1:length(species_ids)){
                search_name <- paste0("txid",species_ids[j],"[Organism]")
                mitogenomes <- tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999))
                # If the search was successful (length >0)
                if(class(mitogenomes)[1] != "try-catch") {
                    if (length(mitogenomes$ids)>0) {
                    # Choose a random mitogenome for the species, and begin filling in row information
                    mito_id <- sample(mitogenomes$ids,1) 
                    row_info <- c(orders_missing$superkingdom[o], orders_missing$kingdom[o], orders_missing$phylum[o], orders_missing$class[o], orders_missing$order[o], species_ids[i], mito_id, "NA")
                    order_seqs <- rbind(order_seqs, row_info)
                    # Clean out the info so the loop is ready for the next search
                    rm(list=c("mito_id","row_info"))
                    # Slow down request to the Entrez server
                    Sys.sleep(1) 
                    } else {
                        # If mitogenomes couldn't be found, look for nucleotide sequences
                        targets <- tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, target_searchterm, collapse=" "), retmax=999999))
                        if(class(targets)[1] != "try-catch") {
                            # If a result was found...
                            if (length(targets$ids)>0) {
                                # Choose a random accession for the species and do the same fill-in as before
                                target_id <- sample(targets$ids,1)
                                row_info <- c(orders_missing$superkingdom[o], orders_missing$kingdom[o], orders_missing$phylum[o], orders_missing$class[o], orders_missing$order[o],species_ids[j], "NA", target_id)
                                order_seqs <- rbind(order_seqs,row_info)
                                rm(list=c("target_id","row_info"))
                                # Slow down request
                                Sys.sleep(1)
                                }
                            }
                            rm(targets)
                        }
                        rm(search_name); rm(mitogenomes)
                    }
                    STOPIT <- "YES"
                }
            }   
        #If there are 3 or fewer species, search them all for a mitogenome or accession then stop searching
        if (length(species_ids_ls[[1]])>3){ 
            # Randomize the species for each order
            species_ids <- sample(species_ids_ls[[1]]) 
            # Start with zero finds
            finds = 0 
            # Add search terms to look for mitogenomes
            for (j in 1:length(species_ids)){
                search_name <- paste0("txid",species_ids[j],"[Organism]")
                mitogenomes <- tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) 
                # If the search was successful...
                if(class(mitogenomes)[1] != "try-catch") { #if the search went through
                    if (length(mitogenomes$ids)>0) {
                        # Choose a random mitogenome and repeat filling in information
                        mito_id <- sample(mitogenomes$ids,1) 
                        row_info <- c(orders_missing$superkingdom[o], orders_missing$kingdom[o], orders_missing$phylum[o], orders_missing$class[o], orders_missing$order[o], species_ids[j], mito_id, "NA")
                        order_seqs <- rbind(order_seqs,row_info)
                        # Add find count and clear out information for the next search
                        finds=finds+1 
                        rm(mito_id) 
                        # Slow request
                        Sys.sleep(1)
                    } else {
                            # If no mitogenomes, repeat the search for nucleotide accessions
                            targets <- tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, target_searchterm, collapse=" "), retmax=999999))
                            if(class(targets)[1] != "try-catch") {
                                if (length(targets$ids)>0) {
                                    # Choose a random accession and add info
                                    target_id <- sample(targets$ids,1) 
                                    row_info <- c(orders_missing$superkingdom[o], orders_missing$kingdom[o], orders_missing$phylum[o], orders_missing$class[o], orders_missing$order[o],species_ids[j], "NA", target_id)
                                    order_seqs <- rbind(order_seqs,row_info)
                                    # Loop counters and slow request
                                    finds=finds+1 
                                    rm(target_id); rm(row_info)
                                    Sys.sleep(1) 
                                    }
                                }
                                rm(targets)
                            }
                            rm(search_name); rm(mitogenomes)
                            if (finds >= 3) break
                            STOPIT <- "YES"
                        }
                } #If there are >=3 species, randomize and search mitogenomes or accessions until you get 3 or have searched them all
            }
            rm(species_ids_ls)
            o=o+1
    }
}

beep(sound = "wilhelm")
```

With the loop done, just need to do some column and row formatting
```{r}
# Subtract the first row because its all NAs
order_seqs <- na.omit(order_seqs) 

# Add columns and fill with NA for easy comparison with the filled in species list
order_seqs$search_name<-"NA"; order_seqs$n_mitogenome<-"NA"; order_seqs$n_target<-"NA"; order_seqs$species<-"NA"; order_seqs$family<-"NA"; order_seqs$genus<-"NA" 

# Add n_mitogenome and n_target columns to count if there was 1 or 0 IDs found
# I don't really understand why or how we were searching for 3 IDs and only get at most one...
order_seqs$n_mitogenome <- ifelse(order_seqs$ids_mitogenome!="NA",1,0)
order_seqs$n_target <- ifelse(order_seqs$ids_target!="NA",1,0)
```


## Step G3: Fill Taxonomy for Missing Orders

With the missing orders identified and a list of species representatives, we now want to fill in the missing taxonomy for those representatives.

First use taxizedb to get full taxonomies, which does get the job done but makes a gross list/classification object. To make it easier to use, we loop through that object to instead populate a dataframe
```{r}
# Get taxonomies for species representatives
taxonomies_orderseqs <- taxizedb::classification(order_seqs$species_id, db="ncbi")

# Set counter
u = 1
```

This loop adds family, genus, and species directly to order_seqs by making new columns
```{r taxonomy_for_order_seqs}
#now loop through the sucky classification object to populate the empty dataframe
for (u in 1:length(taxonomies_orderseqs)) {
  x <- as.data.frame(taxonomies_orderseqs[u])
  
  if (dim(x)[1]>1) {
        c4 <- paste0(x[which(x[,2]=="family"),c(1,3)], collapse="_")
        c5 <- paste0(x[which(x[,2]=="genus"),c(1,3)], collapse="_")
        c6 <- paste0(x[which(x[,2]=="species"),c(1,3)][1,], collapse="_")
  }

   if (exists("c4")){
      if (length(c4) > 0) {
        order_seqs$family[u] <- c4
        } else {
        order_seqs$family[u] <- NA    
        }
    } 
  
  if (exists("c5")){
      if (length(c5) > 0) {
         order_seqs$genus[u] <- c5
        } else {
         order_seqs$genus[u] <- NA    
        }
    } 
  
   if (exists("c6")){
      if (length(c6) > 0) {
        order_seqs$species[u] <- c6
        } else {
        order_seqs$species[u] <- NA    
        }
    } 
  
 suppressWarnings(rm(list = c("x", "tax_query", "c4","c5","c6")))
}

# Fill in the search_name column by removing the species code from the species column (only keeping the binomial)
order_seqs$search_name <- data.frame(do.call(rbind, strsplit(order_seqs$species, split = "_")))[,1]

beep(sound = "wilhelm")
```

Save this interim file in case you need it for the future
```{r missingorder_taxonid_save}
write.csv(order_seqs, file.path(path_outputs, "StepG3Output.csv"), row.names=FALSE)
```


## *Step G4: DISCONTINUED - Scrape Mitogenomes for Missing Order Representatives

Scrape your target locus out of mitogenomes identified in the Entrez search. Note - I need to fix some things here (the loop breaks on parsing errors). If you get stuck, just "m=m+1" and re-start loop
```{r scrape_mitogenomes}
while (m <= dim(specieslist)[1]) { #for every good species name
    cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
    mito_ids <- "na"
    if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
        mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
    } else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
        mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids  
    }
   
    if (mito_ids[1] != "na") { #if there are mitogenome ids for species m
        mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) #ask ENTREZ for id's accession
        if (class(mito_accessions) != "try-catch"){ #if no api error
            mito_accessions <- unlist(strsplit(mito_accessions, split="\n")) #format accession numbers
            for (n in 1:length(mito_accessions)){ # loop through and scrape each mitogenome accession
              new_row <- c(paste("Unparsed mitochondrion", mito_accessions[n], sep=" "), "na", mito_accessions[n], "scrape", species=specieslist$matched_name2[m]) #blank row for each accession
              gb <- tryCatch(readGenBank(GBAccession(mito_accessions[n]))) # get the Genbank annotation for accession
                if (class(gb) != "try-catch"){ #if no error in getting gb
                  if (is_mtgene==FALSE) {# if target locus is not a gene, look in otherFeatures()
                  target_feature <- tryCatch(which(otherFeatures(gb)$product %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata 
                    if (class(target_feature) != "try-catch"){
                      if(length(target_feature) > 0) { # if target feature is found
                        target_range <- tryCatch(otherFeatures(gb)@ranges[target_feature]) #extract the target range info
                          if(class(target_range) != "try-catch"){
                            target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
                              if(class(target_seq) != "try-catch"){
                                scraped_seq <- paste(target_seq) #format
                                new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
                            }
                          }
                      }
                    }
                  }
                  else if (is_mtgene==TRUE){ # if target locus is a gene, look in gene()
                    target_feature <- tryCatch(which(genes(gb)$gene %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata 
                    if (class(target_feature) != "try-catch"){
                      if(length(target_feature) > 0) { # if target feature is found
                        target_range <- tryCatch(genes(gb)@ranges[target_feature])  #extract the target range info
                          if(class(target_range) != "try-catch"){
                            target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
                              if(class(target_seq) != "try-catch"){
                                scraped_seq <- paste(target_seq) #format
                                new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
                            }
                          }
                      }
                    }
                  }
                }
              interim_REFDB <- rbind(interim_REFDB, new_row) # update the database
              rm(gb, target_feature, target_range, target_seq, scraped_seq, new_row) # reset n loop variables
              Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
            } # close n loop (each "n" mitogenome accession per "m" species)
        }
    }
    m=m+1 #update species m variable
    rm(mito_ids, mito_accessions) # reset loop variables
    Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close for each species m loop
```


## Step G5: Scrape Accessions for Missing Order Representatives

For this loop, we repeat the accession scrape as we did for the species list, but this time just for the species representatives of the missing orders. The sequence results will still append to interim_REFDB to join the rest of the sequences. If you want them to be in their own dataframe, just copy the structure of the empty interim_REFDB and name it something else

As usual, set a counter

```{r orderrep_accessions_counter}
s = 1

order_seqs$ids_target <- as.character(order_seqs$ids_target)
```

```{r orderrep_accessions_loop}
while (s <= dim(order_seqs)[1]){ 
    # Display a counter for which species it's on
    cat("\r","scraping accessions for species", s, "of",dim(order_seqs)[1])
    ids <- "na"
    seqs_target <- "na"
    # Scrape GenBank target sequences if available, but skip if >= 100 targets
    if (order_seqs$n_target[s]>0 && order_seqs$n_target[s]<100) { 
     ids <- c(unlist(strsplit(order_seqs$ids_target[s], split="\\|")))
     # If more than 200 accessions, randomly select 100 
      } else if  (order_seqs$n_target[s]>100) {    
     ids <- sample(c(unlist(strsplit(order_seqs$ids_target[s], split="\\|"))),100)
      }
    # If there are accessions, fetch them from GenBank
    if (ids[1] !="na"){ 
        seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
        }
        if(class(seqs_target) != "try-catch"){
            if (seqs_target != "na"){
            # Write out the sequences
            write(seqs_target, file.path(path_outputs, paste(order_seqs$search_name[s], paste0(locus, ".fasta")))) 
            # Read them back in as fasta
            fasta_target <- readDNAStringSet(file.path(path_outputs, paste(order_seqs$search_name[s], paste0(locus, ".fasta"))), format="fasta") 
            # Get accession numbers
            seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc") 
            # Format columns
            seq_header <- names(fasta_target) 
            sequence <- paste(fasta_target) 
            seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n")) 
            # Set lengths equal so any empty spaces will fill with NAs
            length(seq_header) <- length(sequence)
            length(seq_accession) <- length(sequence)
            # Make a temporary database with sequences for the species
            tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=order_seqs$search_name[s]) 
            # Append temporary database to the full database
            interim_REFDB <- rbind(interim_REFDB, tempDB) 
                }
            s=s+1
            }
    #reset loop variables
    fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
    tempDB <-"na"
    #slow down request to the Entrez server or you'll get kicked out
    Sys.sleep(1)
 }

beep(sound = "wilhelm")
```

Save this interim_REFDB
```{r save_interim}
write.csv(interim_REFDB, file.path(path_outputs, "interim_REFDB.csv"), row.names=FALSE)
```


## *Step G6: Summarize Taxonomy and Sequence Results

This chunk is working well to count the number of unique sequences found
```{r summarize_species}
# Count number of unique reference sequences by species into a new df
counts_species <- as.data.frame(table(dedup_REFDB$species)) 

# Set column names
colnames(counts_species) <- c("species", "n_unique_seqs") 

# Add the number of unique sequences to the specieslist
specieslist <- merge(specieslist, counts_species, by.x= "matched_name2", by.y="species", all.x=TRUE, all.y=TRUE)

# Save the now fully updated specieslist as a metadata csv
write.csv(specieslist, file.path(path_outputs, "StepG6_metasum.csv"), row.names=FALSE)
```

Need to fix this up with the changed names to get it properly working
```{r}
a00_SPECIES_SUMMARY <- specieslist[specieslist$matched_name2 %in% specieslist$matched_name2,]

#add in duplicates information to BESTNAMES
a00_SPECIES_SUMMARY$dup_accessions <- "na"
a00_SPECIES_SUMMARY$dup_species <- "na"
a00_SPECIES_SUMMARY$dup_species_n <- "na"

for (b in 1:dim(a00_SPECIES_SUMMARY)[1]){
  dup_accessions <- paste(dedup_REFDB[dedup_REFDB$species == a00_SPECIES_SUMMARY$search_name[b], "duplicate_accessions"], collapse="|")
  dup_accessions <- unlist(strsplit(dup_accessions, split="\\|"))
  dup_accessions_unique <- paste(unique(dup_accessions), collapse="|")
  
  dup_species <- paste(dedup_REFDB[dedup_REFDB$species == a00_SPECIES_SUMMARY$search_name[b], "duplicate_species"], collapse="|")
  dup_species <- unlist(strsplit(dup_species, split="\\|"))
  dup_species_unique <- unique(dup_species)
  
    if (length(dup_accessions)>0){
  a00_SPECIES_SUMMARY$dup_accessions[b]<-dup_accessions_unique
  a00_SPECIES_SUMMARY$dup_species[b]<- paste(dup_species_unique, collapse="|")
  a00_SPECIES_SUMMARY$dup_species_n[b]<- length(dup_species_unique)
  }
  
  #reset variables
  rm(dup_accessions)
  rm(dup_species)
}

a00_SPECIES_SUMMARY$n_all_seqs <- a00_SPECIES_SUMMARY$n_mitogenome + a00_SPECIES_SUMMARY$n_target
n_species_withnames <- dim(a00_SPECIES_SUMMARY)[1]
n_species_withnamesANDtargets <- length(which(a00_SPECIES_SUMMARY$n_all_seqs>0))
#n_species_nonames <- dim(species_list_missing)[1]
#write.csv(a00_SPECIES_SUMMARY, file.path(path_outputs, "a00_SPECIES_SUMMARY.csv"), row.names=FALSE)

n_species_withnames; n_species_withnamesANDtargets#; n_species_nonames
```



# Reference Database Clean-Up

Whether or not you chose to do the Gap Analysis, follow these steps to clean up your reference database for compatibility with dada2

## Step C1: De-Duplication

To remove duplicates, we first remove the first row from a02_REFBD (which is all NAs), then create a new refdb by picking out only the unique sequences. We still want to keep a record of the identical accession numbers though, so iterate over the loop to track the accession IDs of the identical sequences into a new column

```{r remove_duplicates}
# Remove the top row of NAs
interim_REFDB <- interim_REFDB[-1,] 

# Remove duplicates
dedup_REFDB <- interim_REFDB[!duplicated(interim_REFDB$sequence),]
```

As usual, set a loop counter
```{r duplicate_counter}
z = 1
```

This will add a new column into the dedup_REFDB object
```{r duplicate_loop}
# for every row in the unique db file
for (z in  1:dim(dedup_REFDB)[1]){ 
  # find identical sequences in the full db file 
  dups <- subset(interim_REFDB, sequence == dedup_REFDB$sequence[z]) 
  # paste all those accessions together into a new unique db field
  dedup_REFDB$duplicate_accessions[z] <- paste(dups$seq_accession, collapse = "|") 
  dedup_REFDB$duplicate_species[z] <- paste(dups[!duplicated(dups$species),"species"], collapse = "|")
  z=z+1
}

# Also remove row names
row.names(dedup_REFDB) <- NULL
```

When the deduplicated database is done, save it to the output
```{r save_dedup}
write.csv(dedup_REFDB, file.path(path_outputs, "StepC1_dedup.csv"), row.names=FALSE)
```


## Step C2: Format for DADA2

Format the reference library for dada2 assignTaxonomy()
```{r format_dada2}

# Merge the specieslist and deduplicated database together
REFDB_dada_merge <- merge(x=dedup_REFDB, y=specieslist, by.x="species", by.y="matched_name2", all.x=TRUE, all.y=FALSE) 

# Select the taxonomy columns (provided in the filled out specieslist) and sequence column (from the deduplicated database)
my_cols <- c("phylum", "class","order","family","genus","species.y")

# Paste only those columns into a header column, separated by ;
REFDB_dada_merge$header <- do.call(paste, c(REFDB_dada_merge[my_cols], sep = ";"))

# Add a > to the front of the header
REFDB_dada_merge$header2 <- paste(">",REFDB_dada_merge$header, sep="")

# Keep only the finished header and the sequence
REFDB_dada <- REFDB_dada_merge[,c("header2","sequence")]

# Save the dada-formatted reference database
write.table(REFDB_dada, file.path(path_outputs, "COI_REFDB.fasta"), sep="\n", col.names=FALSE, row.names=FALSE, quote=FALSE)
```
