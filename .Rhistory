??gnr_resolve
gnr_datasources()
sourcefull <- gnr_datasources()
View(sourcefull)
sources <- c(4, 9, 11, 12, 44)
speciesqc <- readRDS("C:/Users/bydav/Desktop/SpeciesList_Cleaning2024/updatedspecieslist.RDS")
# break-up names into vectors of at most 500
splitNames <- split(speciesqc$SpeciesBinomial,
ceiling(seq_along(speciesqc$SpeciesBinomial)/1000))
View(speciesqc)
class(speciesqc$Species_Name)
class(speciesqc$Source)
View(speciesqc)
View(listbase)
View(metadf)
GBIF <- read.table('C:/Users/bydav/Desktop/GBIFNovSpeciesList.csv', sep = '\t', fill = TRUE, header = TRUE, encoding = 'UTF-8')
GBIF <- read.table('C:/Users/bydav/Desktop/SpeciesList_Cleaning2024/GBIFNovSpeciesList.csv', sep = '\t', fill = TRUE, header = TRUE, encoding = 'UTF-8')
nonGBIFlist <- readRDS("C:/Users/bydav/Desktop/SpeciesList_Cleaning2024/nonGBIFlist.RDS")
View(nonGBIFlist)
# RDS files can be called with readRDS(file = "")
nonGBIFlist = readRDS(file = "C:\\Users\\bydav\\Desktop\\nonGBIFlist.RDS")
# RDS files can be called with readRDS(file = "")
nonGBIFlist = readRDS(file = "C:\\Users\\bydav\\Desktop\\SpeciesList_Cleaning2024/nonGBIFlist.RDS")
GBIF <- read.table('C:/Users/bydav/Desktop/SpeciesList_Cleaning2024/GBIFNovSpeciesList.csv', sep = '\t', fill = TRUE, header = TRUE, encoding = 'UTF-8')
# Only pull the species names - we don't need any other info here
GBIFspecies <- unique(GBIF[, 10])
# Coerce to dataframe
GBIFResults <- as.data.frame(GBIFspecies)
# Update column name
colnames(GBIFResults) <- c("SpeciesBinomial")
# add a column for "Source" and add 29 (the source code for GBIF) to each row
GBIFdf <- GBIFResults %>%
mutate(Source = 29)
# Append the GBIF list to our eukaryalist and set a notification for when it's done
updatedeukarya <- (rbind(GBIFdf, nonGBIFlist))
head(GBIFdf)
??colnames
# Update column name
colnames(GBIFResults) <- c("SpeciesBinomial", "SourceList")
head(GBIFResults)
GBIFdf <- GBIFResults %>%
mutate(SourceList = 29)
head(GBIFdf)
# Append the GBIF list to our eukaryalist and set a notification for when it's done
updatedeukarya <- (rbind(GBIFdf, nonGBIFlist))
# Create a list of unique names
filter2 <- unique(updatedeukarya$Species_Name)
metadf2 <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(metadf2) <- c('SpeciesBinomial', 'SourceList')
metadf2
for (i in filter2) {
tempsearch <- updatedeukarya[updatedeukarya$Species_Name == i, ]
tempsource <- list(c(tempsearch$Source))
metadf2[nrow(metadf2) + 1,] = c(unique(tempsearch$Species_Name), 0)
metadf2[nrow(metadf2), ]$SourceList <- tempsource
}
# Create a list of unique names
filter2 <- unique(updatedeukarya$SpeciesBinomial)
for (i in filter2) {
tempsearch <- updatedeukarya[updatedeukarya$Species_Name == i, ]
tempsource <- list(c(tempsearch$Source))
metadf2[nrow(metadf2) + 1,] = c(unique(tempsearch$Species_Name), 0)
metadf2[nrow(metadf2), ]$SourceList <- tempsource
}
head(updatedeukarya)
# Create a list of unique names
filter2 <- unique(updatedeukarya$SpeciesBinomial)
# prep a new dataframe
metadf2 <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(metadf2) <- c('SpeciesBinomial', 'SourceList')
metadf2
for (i in filter2) {
tempsearch <- updatedeukarya[updatedeukarya$SpeciesBinomial == i, ]
tempsource <- list(c(tempsearch$SourceList))
metadf2[nrow(metadf2) + 1,] = c(unique(tempsearch$SpeciesBinomial), 0)
metadf2[nrow(metadf2), ]$SourceList <- tempsource
}
beep(sound = "wilhelm")
View(metadf2)
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- metadf2 %>% filter(str_detect(str_trim(SpeciesBinomial), "\\s+"))
# Force encoding
speciesqc$SpeciesBinomial<- stri_trans_general(speciesqc$SpeciesBinomial, "latin-ascii")
# Trim leading and tailing spaces
speciesqc$SpeciesBinomial <- trimws(speciesqc$SpeciesBinomial, which = c("both"))
#There are several entries that contain varieties of 'unknown' that we want to remove. Define vector of strings
exeunt <- c('Unknown', 'Unidentified', 'Undetermined', 'Undetermiend')
#remove rows that contain any string in the vector in the team column
speciesqc <- speciesqc[!grepl(paste(exeunt, collapse='|'), speciesqc$SpeciesBinomial),]
# Remove all symbols/characters that aren't spaces or alphanumeric characters - from rominger_codathon
speciesqc$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", speciesqc$SpeciesBinomial)
speciesqc <- speciesqc[!grepl('sp\\.|cf\\.|f\\.', speciesqc$SpeciesBinomial), , drop = FALSE]
# Papilio canadensis X glaucus causes an Internal Server Error for some reason. Not related to either a lone character or a long string.
# Try overwriting it.
# Identify which row it's in
speciesqc[speciesqc$SpeciesBinomial == "Papilio canadensis X glaucus", ]
# Overwrite
#speciesqc[24219, 1] = "Papilio canadensis glaucus"
# Save the cleaned output as another RDS
#saveRDS(updatedeukarya, file = "C:\\Users\\bydav\\Desktop\\updatedspecieslist.RDS")
# Overwrite
speciesqc[24219, 1] = "Papilio canadensis glaucus"
# break-up names into vectors of at most 500
splitNames <- split(speciesqc$SpeciesBinomial,
ceiling(seq_along(speciesqc$SpeciesBinomial)/1000))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
sources <- c(4, 9, 11, 12, 44)
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = sources,
best_match_only = TRUE,
canonical = TRUE, http = 'post', fields = "all")
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
splist01 <- as.data.frame(xclean[[1]])
splist02 <- as.data.frame(xclean[[2]])
splist03 <- as.data.frame(xclean[[3]])
splist04 <- as.data.frame(xclean[[4]])
splist05 <- as.data.frame(xclean[[5]])
splist06 <- as.data.frame(xclean[[6]])
splist07 <- as.data.frame(xclean[[7]])
splist08 <- as.data.frame(xclean[[8]])
splist09 <- as.data.frame(xclean[[9]])
splist10 <- as.data.frame(xclean[[10]])
splist11 <- as.data.frame(xclean[[11]])
splist12 <- as.data.frame(xclean[[12]])
splist13 <- as.data.frame(xclean[[13]])
splist14 <- as.data.frame(xclean[[14]])
splist15 <- as.data.frame(xclean[[15]])
splist16 <- as.data.frame(xclean[[16]])
splist17 <- as.data.frame(xclean[[17]])
splist18 <- as.data.frame(xclean[[18]])
splist19 <- as.data.frame(xclean[[19]])
splist20 <- as.data.frame(xclean[[20]])
splist21 <- as.data.frame(xclean[[21]])
splist22 <- as.data.frame(xclean[[22]])
splist23 <- as.data.frame(xclean[[23]])
splist24 <- as.data.frame(xclean[[24]])
splist25 <- as.data.frame(xclean[[25]])
splist26 <- as.data.frame(xclean[[26]])
splist27 <- as.data.frame(xclean[[27]])
splist28 <- as.data.frame(xclean[[28]])
splist29 <- as.data.frame(xclean[[29]])
splist <- rbind(splist01, splist02, splist03, splist04, splist05, splist06, splist07, splist08, splist09, splist10, splist11, splist12, splist13, splist14, splist15,splist16, splist17, splist18, splist19, splist20, splist21, splist22, splist23, splist24, splist25, splist26, splist27, splist28, splist29)
??rbind
head(splist20)
colnames(splist15)
colnames(splist20)
colnames(splist19)
colnames(splist13)
colnames(splist21)
head(splist18[19])
head(splist18[18])
# Separate the ones with different numbers of columns
splistv2 <- rbind(splist01, splist03, splist05, splist06, splist07, splist08, splist12, splist13, splist15, splist16, splist17)
splistv1 <- rbind(splist02, splist04, splist09, splist10, splist11, splist14, splist18, splist19, splist20, splist21, splist22, splist23, splist24, splist25, splist26, splist27, splist 28, splist29)
splistv1 <- rbind(splist02, splist04, splist09, splist10, splist11, splist14, splist18, splist19, splist20, splist21, splist22, splist23, splist24, splist25, splist26, splist27, splist28, splist29)
head(splistv1[1])
head(splistv1[0])
splistv11 <- subset(splistv1[1:17])
splist <- rbind(splistv11, splistv2)
# Update formatting for match_value and match_type
splist$match_value <- as.factor(splist$match_value)
splist$match_type <- as.factor(splist$match_type)
# Taxa that could only be identified to genus + deduplication
splist_GenusOnly <- subset(splist, match_value == "Could only match genus")
# fill in genus name
splist_GenusOnly$genus <- vapply(strsplit(splist_GenusOnly$matched_name," "), `[`, 1, FUN.VALUE=character(1))
splist_UniqueGenusOnly <- splist_GenusOnly[!duplicated(splist_GenusOnly$genus),]
# Taxa that could be identified to species + deduplication
splist_Species <- subset(splist, match_value != "Could only match genus")
splist_UniqueSpecies <- splist_Species[!duplicated(splist_Species$matched_name),]
splist_UniqueSpecies$superkingdom <- "na"; splist_UniqueSpecies$kingdom <- "na";
splist_UniqueSpecies$phylum <- "na"; splist_UniqueSpecies$class <- "na";
splist_UniqueSpecies$order <- "na"; splist_UniqueSpecies$family <- "na";
splist_UniqueSpecies$genus <- "na"; splist_UniqueSpecies$species <- "na"
s=1
for (s in 1:dim(splist_UniqueSpecies)[1]) {
paths <- unlist(strsplit(splist_UniqueSpecies$classification_path[s], "|", fixed=TRUE))
ranks <- unlist(strsplit(splist_UniqueSpecies$classification_path_ranks[s], "|", fixed=TRUE))
temp <- as.data.frame(cbind(paths, ranks))
if (length(which(temp$ranks=="superkingdom"))>0){
splist_UniqueSpecies$superkingdom[s] <- temp[which(temp$ranks=="superkingdom"), 1]
}
if (length(which(temp$ranks=="kingdom"))>0){
splist_UniqueSpecies$kingdom[s] <- temp[which(temp$ranks=="kingdom"), 1]
}
if (length(which(temp$ranks=="phylum"))>0){
splist_UniqueSpecies$phylum[s] <- temp[which(temp$ranks=="phylum"), 1]
}
if (length(which(temp$ranks=="class"))>0){
splist_UniqueSpecies$class[s] <- temp[which(temp$ranks=="class"), 1]
}
if (length(which(temp$ranks=="order"))>0){
splist_UniqueSpecies$order[s] <- temp[which(temp$ranks=="order"), 1]
}
if (length(which(temp$ranks=="family"))>0){
splist_UniqueSpecies$family[s] <- temp[which(temp$ranks=="family"), 1]
}
if (length(which(temp$ranks=="genus"))>0){
splist_UniqueSpecies$genus[s] <- temp[which(temp$ranks=="genus"), 1]
}
if (length(which(temp$ranks=="species"))>0){
splist_UniqueSpecies$species[s] <- temp[which(temp$ranks=="species"), 1]
}
rm(paths, ranks, temp)
s=s+1
}
beep(sound = "fanfare")
# Save the splist_UniqueGenusOnly and splist_UniqueSpecies outputs
saveRDS(splist_UniqueGenusOnly, file = "C:\\Users\\bydav\\Desktop\\GNRSpList_GenusOnly.RDS")
saveRDS(splist_UniqueSpecies, file = "C:\\Users\\bydav\\Desktop\\GNRSpList_Species.RDS")
# Save full output
saveRDS(splist_UniqueSpecies, file = "C://Users//bydav//Desktop//MaineSpeciesList.RDS")
# Locate the species binomials that were left out after GNR resolve.
sp_unID <- setdiff(speciesqc$SpeciesBinomial, splist_UniqueSpecies$user_supplied_name)
saveRDS(sp_unID, file = "C:\\Users\\bydav\\Desktop\\Unidentified_Species.RDS")
# Add source info to the GNR_resolved names
SpList_wSource <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "first",
unmatched = "drop",
relationship = "many-to-many"
)
# Save full output
saveRDS(splist_UniqueSpecies, file = "C://Users//bydav//Desktop//MaineSpeciesList.RDS")
# Remove bacteria but not fungi
eukaryota <- subset(SpList_wSource, superkingdom == "Eukaryota")
# Save output without bacteria
saveRDS(eukaryota, file = "C:\\Users\\bydav\\Desktop\\GNREukaryotaList.RDS")
# Remove fungi but not bacteria
nofungusamongus <- subset(SpList_wSource, kingdom != "Fungi")
# Save output without fungi
saveRDS(nofungusamongus, file = "C:\\Users\\bydav\\Desktop\\GNRNoFungusSpeciesList.RDS")
# Remove bacteria and not fungi
clean_eukaryota <- subset(eukaryota, kingdom != "Fungi")
# Save output without bacteria
saveRDS(clean_eukaryota, file = "C:\\Users\\bydav\\Desktop\\GNREukaryota_NoFungus.RDS")
View(splist_UniqueSpecies)
# Save full output
saveRDS(splist_UniqueSpecies, file = "C://Users//bydav//Desktop//GNRMaineSpeciesList.RDS")
# Save a full species list but without the less helpful (for later steps) GNR columns
tailor_spUnique <- subset(splist_UniqueSpecies[1,2,4,6])
?subset
# Save a full species list but without the less helpful (for later steps) GNR columns
tailor_spUnique <- subset(splist_UniqueSpecies, splist_UniqueSpecies[1,2,4,6])
library(taxizedb) #checks taxonomy
library(rentrez) #queries ENTREZ databases and downloads accessions
library(AnnotationBustR) #finds longest accessions, slice genes from mitogenomes
library(reutils) #other packages need it
library(ape) #convert fasta, fastq, etc.
library(ggplot2) #plots
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("Biostrings")
set_entrez_key(3ea6e1aa8c14a35da5a0650d0d4e77f9aa09) #set the Entrez API key
set_entrez_key("3ea6e1aa8c14a35da5a0650d0d4e77f9aa09") #set the Entrez API key
dir.create("C://Users//bydav//Desktop//TaxonomyAttempt")
# create search terms for ENTREZ
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
more_12Ssynonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA") # other synonyms that we find go here and get added to AnnotationBustR's list
mtDNAterms <- rbind(mtDNAterms, more_12Ssynonyms) #format
is_mtgene <- locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
more_12Ssynonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA") # other synonyms that we find go here and get added to AnnotationBustR's list
mtDNAterms <- rbind(mtDNAterms, more_12Ssynonyms) #format
is_mtgene <- locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
View(mtDNAterms)
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
more_12Ssynonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA") # other synonyms that we find go here and get added to AnnotationBustR's list
mtDNAterms <- rbind(mtDNAterms, more_12Ssynonyms) #format
is_mtgene <- Locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
target_locus_synonyms <- mtDNAterms[mtDNAterms$Locus==Locus,] #the target synonyms
View(more_12Ssynonyms)
target_locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target synonyms
# create search terms for ENTREZ
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
entrez_key <- "3ea6e1aa8c14a35da5a0650d0d4e77f9aa09" #GET YOUR OWN ENTREZ KEY AND PUT IT HERE!
locus = "COI" #name of target locus, your choices are
output_folder <- "C://Users//bydav//Desktop//TaxonomyAttempt" #name of your output folder every time
species_list <- readRDS("C://Users//bydav//Desktop//GNRMaineSpeciesList.RDS") # your species list
colnames(species_list)<- c("species")
set_entrez_key(entrez_key) #set the Entrez API key
dir.create(outputfolder)
dir.create(output_folder)
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
more_12Ssynonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA") # other synonyms that we find go here and get added to AnnotationBustR's list
mtDNAterms <- rbind(mtDNAterms, more_12Ssynonyms) #format
is_mtgene <- Locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
is_mtgene <- locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
target_locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target synonyms
target_locus_synonyms$Terms <- paste0("OR ", target_locus_synonyms$Name, "[TITL]") # format for ENTREZ search terms
target_locus_synonyms$Terms[1] <- paste0("AND (", target_locus_synonyms$Name[1], "[TITL]") # first term starts with "AND ("
target_locus_synonyms$Terms[dim(target_locus_synonyms)[1]] <- paste0("OR ", target_locus_synonyms$Name[dim(target_locus_synonyms)[1]], "[TITL])") #last term ends with a ")"
target_locus_searchterm <- paste(as.vector(target_locus_synonyms$Terms), collapse=" ") # the big ENTREZ search term
# create empty dataframes to fill in during loops
tax_df <- as.data.frame(matrix(nrow=1, ncol=9, dimnames=list(NULL, c("tax_query", "superkingdom", "kingdom", "phylum", "class", "order", "family", "genus", "species")))) # taxonomy skeleton
order_seqs <- as.data.frame(matrix(nrow=1, ncol=8, dimnames=list(NULL, c("superkingdom", "kingdom", "phylum", "class", "order", "species_id", "ids_mitogenome","ids_target")))) #  missing orders skeleton
a02_REFDB <- data.frame(seq_header=NA, sequence=NA, seq_accession=NA, type=NA, species=NA) #create reference database skeleton
species_list_dedup <- unique(species_list$search_name) #de-duplicated the species list
db_tax_NCBI <- db_download_ncbi(verbose = TRUE, overwrite = FALSE) #download the NCBI taxonomy database
head(species_list)
colnames(species_list)
species_list <- readRDS("C://Users//bydav//Desktop//GNRMaineSpeciesList.RDS") # your species list
colnames(species_list)
a01_NAMES <- subset(species_list, species_list[18:25])
a01_NAMES <- species_list[18:25]
colnames(a01_NAMES)
hile (i <= dim(a01_NAMES)[1]){
while (i <= dim(a01_NAMES)[1]){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES)[1]) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
while (i <= dim(a01_NAMES)[1]){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES)[1]) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
View(a01_NAMES)
View(a02_REFDB)
while (i <= dim(a01_NAMES)[1]){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES)[1]) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
data(mtDNAterms) #AnnotationBustR's list of synonyms for different loci
more_12Ssynonyms <- data.frame(Locus="rRNA_12S", Type="rRNA", Name= "small ribosomal RNA subunit RNA") # other synonyms that we find go here and get added to AnnotationBustR's list
mtDNAterms <- rbind(mtDNAterms, more_12Ssynonyms) #format
is_mtgene <- locus %in% c("ATP6", "ATP8",  "COI",  "COII",  "COIII",  "CYTB",  "ND1",  "ND2",  "ND3",  "ND4", "ND4L", "ND5",  "ND6") #check whether the locus is a gene or other feature, needed for the mitogenome scrape
target_locus_synonyms <- mtDNAterms[mtDNAterms$Locus==locus,] #the target synonyms
target_locus_synonyms$Terms <- paste0("OR ", target_locus_synonyms$Name, "[TITL]") # format for ENTREZ search terms
target_locus_synonyms$Terms[1] <- paste0("AND (", target_locus_synonyms$Name[1], "[TITL]") # first term starts with "AND ("
target_locus_synonyms$Terms[dim(target_locus_synonyms)[1]] <- paste0("OR ", target_locus_synonyms$Name[dim(target_locus_synonyms)[1]], "[TITL])") #last term ends with a ")"
target_locus_searchterm <- paste(as.vector(target_locus_synonyms$Terms), collapse=" ") # the big ENTREZ search term
```{r search_entrez}
colnames(a01_NAMES)
while (i <= dim(a01_NAMES$species)){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES$species) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
while (i <= dim(a01_NAMES$species)){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES$species) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
i = test
i = testy
i <- c("testy")
search_name <- paste0(a01_NAMES$species[i],"[ORGN]")
while (i <= dim(a01_NAMES$species)){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES$species)) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
dim(a01_NAMES$species)
dim(a01_NAMES[8])
while (i <= dim(a01_NAMES[8])){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES[8])) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
while (i <- dim(a01_NAMES[8])){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES[8])) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
while (i <= dim(a01_NAMES[8])){
cat("\r", "finding Genbank accessions & mitogenomes for species", i, "of", dim(a01_NAMES[8])) #counter
# define search terms for species
search_name <- paste0(a01_NAMES$species[i],"[ORGN]") #format species name for ENTREZ search
search_term <- paste(search_name, target_locus_searchterm, collapse=" ") #mash species & locus terms into one search term
# search ENTREZ for mitogenomes and then for accessions
tryCatch(entrez_search(db="nucleotide", term <- paste(search_name, "AND mitochondrion[TITL] AND complete genome[TITL]"), retmax=9999)) -> mitogenomes # search mitogenomes
if(class(mitogenomes)[1] != "try-catch") {
a01_NAMES$n_mitogenome[i] <-mitogenomes$count #add mitogenome count names dataframe
a01_NAMES$ids_mitogenome[i] <-paste(mitogenomes$ids, collapse="|") #add mitogenome ids to name dataframe
tryCatch(entrez_search(db="nucleotide", term <- search_term, retmax=9999)) -> targets # search accessions
if(class(targets)[1] != "try-catch") {
a01_NAMES$n_target[i] <-targets$count
a01_NAMES$ids_target[i] <- paste(targets$ids, collapse="|")
}
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
# reset loop variables
mitogenomes <- "na"
targets <- "na"
search_name <- "na"
search_term <- "na"
i <- i + 1
}
??tryCatch
# pick out just the found species to test with Erin's workflow:
write.csv(subset(splist_UniqueSpecies[8]), "C://Users//bydav//Desktop//SpeciesOnly.csv")
GNREukaryotaList <- readRDS("C:/Users/bydav/Desktop/GNREukaryotaList.RDS")
View(GNREukaryotaList)
>>>>>>> 9c386170120d7e694ec436cc142232b5dd0f9d6c
