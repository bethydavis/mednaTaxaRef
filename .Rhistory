if (length(which(temp$ranks=="phylum"))>0){
goodnames_UniqueSpecies$phylum[s] <- temp[which(temp$ranks=="phylum"), 1]
}
if (length(which(temp$ranks=="class"))>0){
goodnames_UniqueSpecies$class[s] <- temp[which(temp$ranks=="class"), 1]
}
if (length(which(temp$ranks=="order"))>0){
goodnames_UniqueSpecies$order[s] <- temp[which(temp$ranks=="order"), 1]
}
if (length(which(temp$ranks=="family"))>0){
goodnames_UniqueSpecies$family[s] <- temp[which(temp$ranks=="family"), 1]
}
if (length(which(temp$ranks=="genus"))>0){
goodnames_UniqueSpecies$genus[s] <- temp[which(temp$ranks=="genus"), 1]
}
if (length(which(temp$ranks=="species"))>0){
goodnames_UniqueSpecies$species[s] <- temp[which(temp$ranks=="species"), 1]
}
rm(paths, ranks, temp)
s=s+1
}
View(goodnames_GenusOnly)
speciesqc2 <- read.csv("C:\\Users\\bydav\\Desktop\\MetaListPreTaxonomy.csv")
#head(speciesqc2$SpeciesBinomial)
speciesqc2$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", speciesqc2$SpeciesBinomial)
#speciesqc2[speciesqc2$SpeciesBinomial == "Epeorus (I.) vitreus", ]
#speciesqc2[speciesqc2$SpeciesBinomial == "Epeorus I vitreus", ]
#
#trim leading and tailing spaces
speciesqc2$SpeciesBinomial <- trimws(speciesqc2$SpeciesBinomial, which = c("both"))
View(speciesqc2)
splitNames <- split(speciesqc2$SpeciesBinomial,
ceiling(seq_along(speciesqc2$SpeciesBinomial)/1000))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
# break-up names into vectors of at most 500
splitNames <- split(speciesqc2$SpeciesBinomial,
ceiling(seq_along(speciesqc2$SpeciesBinomial)/50))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
xclean[[479]]
print(n=50)
View(xclean)
print(n=50, xclean[[479]])
print(n=50, splitNames[[479]])
splitNames[[479]]
xclean[[480]]
splitNames[[480]]
output <- gnr_resolve(splitNames[[480]], resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = 'post)
output <- gnr_resolve(splitNames[[480]], resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = 'post')
output <- gnr_resolve(splitNames[[480]], resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
trouble <- as.data.frame(splitNames[[480]])
View(trouble)
output <- gnr_resolve(trouble, resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio canadensis X glaucus", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papaipema leucostigma", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio polyxenes", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio X polyxenes", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio Y polyxenes", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Scientific Name", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio canadensis X glaucus", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio canadensis X", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio canadensis glaucus", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
gnr_resolve("Papilio canadensis X glaucus", resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
speciesqc2[speciesqc2$SpeciesBinomial == "Papilio canadensis X glaucus", ]
head(speciesqc2[1])
head(speciesqc2[2])
speciesqc2[1, 23955]
speciesqc2[23955, 1]
speciesqc2[23955, 1] = "Papilio canadensis glaucus"
speciesqc2[23955, 1]
for(i in 490:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
ranks <- c('kingdom', 'phylum', 'class', 'order', 'family', 'genus', 'species')
tempDF <- as.data.frame(matrix(NA, nrow = 1, ncol = length(ranks)))
names(tempDF) <- ranks
View(xclean)
for(i in 480:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
# break-up names into vectors of at most 500
splitNames <- split(speciesqc2$SpeciesBinomial,
ceiling(seq_along(speciesqc2$SpeciesBinomial)/50))
for(i in 480:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
higherTax <- taxizedb::classification(xclean$matched_name2, db = 'ncbi')
test1 <- as.data.frame(xclean[[1]])
View(test1)
listbase <- read.csv("C:/Users/bydav/Desktop/SpeciesListMeta.csv", header = TRUE, encoding = 'UTF-8')
# Create a list of unique names
filter <- unique(eukaryalist$Species_Name)
# specieslist without the removals:
eukaryalist <- listbase
# Create a list of unique names
filter <- unique(eukaryalist$Species_Name)
# prep a new dataframe
metadf <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(metadf) <- c('SpeciesBinomial', 'SourceList')
metadf
for (i in filter) {
tempsearch <- eukaryalist[eukaryalist$Species_Name == i, ]
tempsource <- list(c(tempsearch$Source))
metadf[nrow(metadf) + 1,] = c(unique(tempsearch$Species_Name), 0)
metadf[nrow(metadf), ]$SourceList <- tempsource
}
beep(sound = "wilhelm")
saveRDS(metadf, file = "C:\\Users\\bydav\\Desktop\\nonGBIFlist.RDS")
# this has the source lists as numbers separated with |, which isn't ideal but honestly better than previous attempts.
testload <- readRDS("C:\\Users\\bydav\\Desktop\\nonGBIFlist.RDS")
head(testload)
GBIF <- read.table('C:/Users/bydav/Desktop/GBIFNovSpeciesList.csv', sep = '\t', fill = TRUE, header = TRUE, encoding = 'UTF-8')
GBIFspecies <- unique(GBIF[, 10])
GBIFResults <- as.data.frame(GBIFspecies)
colnames(GBIFResults) <- c("Species_Name")
GBIFdf <- GBIFResults %>%
mutate(Source = 29)
library(beepr) # to notify when long chunks are done
library(dplyr) # for cleaning
library(tidyverse) # for cleaning
library(taxize) # for taxonomy
library(rotl) # for taxonomy
library(stringi) # for cleaning
GBIFdf <- GBIFResults %>%
mutate(Source = 29)
# Append the GBIF list to our eukaryalist and set a notification for when it's done
updatedeukarya <- (rbind(GBIFdf, eukaryalist))
beep(sound = "fanfare")
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- updatedeukarya %>% filter(str_detect(str_trim(SpeciesBinomial), "\\s+"))
View(updatedeukarya)
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- updatedeukarya %>% filter(str_detect(str_trim(Species_Name, "\\s+"))
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- updatedeukarya %>% filter(str_detect(str_trim(Species_Name, "\\s+")))
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- updatedeukarya %>% filter(str_detect(str_trim(Species_Name, "\\s+")))
#There are several entries that contain varieties of 'unknown' that we want to remove. Define vector of strings
exeunt <- c('Unknown', 'Unidentified', 'Undetermined', 'Undetermiend')
str_trim("  String with trailing and leading white space\t")
str_trim("\n\nString with trailing and leading white space\n\n")
str_squish("  String with trailing,  middle, and leading white space\t")
str_squish("\n\nString with excess,  trailing and leading white   space\n\n")
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- updatedeukarya %>% filter(str_detect(str_squish(Species_Name)))
# Create a list of unique names
filter2 <- unique(updatedeukarya$Species_Name)
# prep a new dataframe
metadf2 <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(metadf2) <- c('SpeciesBinomial', 'SourceList')
metadf2
for (i in filter2) {
tempsearch <- updatedeukarya[updatedeukarya$Species_Name == i, ]
tempsource <- list(c(tempsearch$Source))
metadf2[nrow(metadf2) + 1,] = c(unique(tempsearch$Species_Name), 0)
metadf2[nrow(metadf2), ]$SourceList <- tempsource
}
beep(sound = "wilhelm")
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- metadf2 %>% filter(str_detect(str_trim(SpeciesBinomial, "//s+")))
# Remove all rows that don't have any whitespace - this should remove the Genus-only entries
speciesqc <- metadf2 %>% filter(str_detect(str_trim(SpeciesBinomial, "//s")))
View(metadf2)
# Remove all symbols/characters that aren't spaces or alphanumeric characters
metadf2$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", metadf2$SpeciesBinomial)
# Remove all rows that don't have whitespace in the SpeciesBinomial - this should leave us only with the species that have actual species binomials
speciesqc <- metadf2 %>% filter(str_detect(str_trim(SpeciesBinomial), "\\s+"))
#remove rows that contain any string in the vector in the team column
speciesqc$SpeciesBinomial <- speciesqc[!grepl(paste(exeunt, collapse='|'), speciesqc$SpeciesBinomial),]
View(speciesqc)
# Force encoding
speciesqc$SpeciesBinomial<- stri_trans_general(speciesqc$SpeciesBinomial, "latin-ascii")
# Remove all symbols/characters that aren't spaces or alphanumeric characters
metadf2$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", metadf2$SpeciesBinomial)
# Trim leading and tailing spaces
speciesqc$SpeciesBinomial <- trimws(speciesqc$SpeciesBinomial, which = c("both"))
#remove rows that contain any string in the vector in the team column
speciesqc <- speciesqc[!grepl(paste(exeunt, collapse='|'), speciesqc$SpeciesBinomial),]
# Remove all symbols/characters that aren't spaces or alphanumeric characters
metadf2$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", metadf2$SpeciesBinomial)
# Remove all symbols/characters that aren't spaces or alphanumeric characters
speciesqc$SpeciesBinomial <- gsub("[^[:alnum:][:space:]]", "", speciesqc$SpeciesBinomial)
speciesqc[speciesqc$SpeciesBinomial = "Isoetes", ]
speciesqc[speciesqc$SpeciesBinomial == "Isoetes", ]
speciesqc <- speciesqc[!grepl('sp\\.|cf\\.|f\\.', speciesqc$SpeciesBinomial), , drop = FALSE]
# Save the cleaned output as another RDS
saveRDS(updatedeukarya, file = "C:\\Users\\bydav\\Desktop\\updatedspecieslist.RDS")
speciesqc[23955, 1]
speciesqc[speciesqc$SpeciesBinomial == "Papilio canadensis X glaucus", ]
speciesqc[24219, 1]
# Identify which row it's in
speciesqc[speciesqc$SpeciesBinomial == "Papilio canadensis X glaucus", ]
# Overwrite
speciesqc[24219, 1] = "Papilio canadensis glaucus"
# Save the cleaned output as another RDS
saveRDS(updatedeukarya, file = "C:\\Users\\bydav\\Desktop\\updatedspecieslist.RDS")
# break-up names into vectors of at most 500
splitNames <- split(speciesqc$SpeciesBinomial,
ceiling(seq_along(speciesqc$SpeciesBinomial)/50))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post')
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
beep(sound = "wilhelm")
#trouble <- as.data.frame(splitNames[[480]])
#output <- gnr_resolve(trouble, resolve_once = TRUE, preferred_data_sources = 4, best_match_only = TRUE, canonical = TRUE, http = "post")
# break-up names into vectors of at most 500
splitNames <- split(speciesqc$SpeciesBinomial,
ceiling(seq_along(speciesqc$SpeciesBinomial)/500))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post', fields = "all")
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
beep(sound = "wilhelm")
# break-up names into vectors of at most 500
splitNames <- split(speciesqc$SpeciesBinomial,
ceiling(seq_along(speciesqc$SpeciesBinomial)/1000))
# make a list to populate with results from `gnr_resolve`
xclean <- vector('list', length(splitNames))
for(i in 1:length(xclean)) {
# `preferred_data_source = 4` is for NCBI
# set `http = 'post'` for large query
xclean[[i]] <- gnr_resolve(splitNames[[i]],
resolve_once = TRUE, preferred_data_sources = 4,
best_match_only = TRUE,
canonical = TRUE, http = 'post', fields = "all")
cat('# ----\n')
cat(i, '\n')
print(dim(xclean[[i]]))
cat(' \n')
}
beep(sound = "wilhelm")
splist01 <- as.data.frame(xclean[[1]])
View(splist01)
# Save as an intermediate RDS
saveRDS(xclean, file = "C:\\Users\\bydav\\Desktop\\GNRSpList.RDS")
splist01 <- as.data.frame(xclean[[1]])
splist02 <- as.data.frame(xclean[[2]])
splist03 <- as.data.frame(xclean[[3]])
splist04 <- as.data.frame(xclean[[4]])
splist05 <- as.data.frame(xclean[[5]])
splist06 <- as.data.frame(xclean[[6]])
splist07 <- as.data.frame(xclean[[7]])
splist08 <- as.data.frame(xclean[[8]])
splist09 <- as.data.frame(xclean[[9]])
splist10 <- as.data.frame(xclean[[10]])
splist11 <- as.data.frame(xclean[[11]])
splist12 <- as.data.frame(xclean[[12]])
splist13 <- as.data.frame(xclean[[13]])
splist14 <- as.data.frame(xclean[[14]])
splist15 <- as.data.frame(xclean[[15]])
splist16 <- as.data.frame(xclean[[16]])
splist17 <- as.data.frame(xclean[[17]])
splist18 <- as.data.frame(xclean[[18]])
splist19 <- as.data.frame(xclean[[19]])
splist20 <- as.data.frame(xclean[[20]])
splist21 <- as.data.frame(xclean[[21]])
splist22 <- as.data.frame(xclean[[22]])
splist23 <- as.data.frame(xclean[[23]])
splist24 <- as.data.frame(xclean[[24]])
splist25 <- as.data.frame(xclean[[25]])
splist26 <- as.data.frame(xclean[[26]])
splist27 <- as.data.frame(xclean[[27]])
splist28 <- as.data.frame(xclean[[28]])
splist29 <- as.data.frame(xclean[[29]])
splist <- rbind(splist01, splist02, splist03, splist04, splist05, splist06, splist07, splist08, splist09, splist10, splist11, splist12, splist13, splist14, splist15,splist16, splist17, splist18, splist19, splist20, split21, splist22, splist23, splist24, splist25, splist26, splist27, splist28, splist29)
splist <- rbind(splist01, splist02, splist03, splist04, splist05, splist06, splist07, splist08, splist09, splist10, splist11, splist12, splist13, splist14, splist15,splist16, splist17, splist18, splist19, splist20, splist21, splist22, splist23, splist24, splist25, splist26, splist27, splist28, splist29)
saveRDS(splist, file = "C:\\Users\\bydav\\Desktop\\GNRSpDF.RDS")
# Update formatting for match_value and match_type
splist$match_value <- as.factor(splist$match_value)
splist$match_type <- as.factor(splist$match_type)
# Taxa that could only be identified to genus + deduplication
splist_GenusOnly <- subset(splist, match_value == "Could only match genus")
# fill in genus name
splist_GenusOnly$genus <- vapply(strsplit(splist_GenusOnly$matched_name," "), `[`, 1, FUN.VALUE=character(1))
splist_UniqueGenusOnly <- splist_GenusOnly[!duplicated(splist_GenusOnly$genus),]
# Taxa that could be identified to species + deduplication
splist_Species <- subset(splist, match_value != "Could only match genus")
splist_UniqueSpecies <- splist_Species[!duplicated(splist_Species$matched_name),]
splist_UniqueSpecies$superkingdom <- "na"; splist_UniqueSpecies$kingdom <- "na";
splist_UniqueSpecies$phylum <- "na"; splist_UniqueSpecies$class <- "na";
splist_UniqueSpecies$order <- "na"; splist_UniqueSpecies$family <- "na";
splist_UniqueSpecies$genus <- "na"; splist_UniqueSpecies$species <- "na"
s=1
for (s in 1:dim(splist_UniqueSpecies)[1]) {
paths <- unlist(strsplit(splist_UniqueSpecies$classification_path[s], "|", fixed=TRUE))
ranks <- unlist(strsplit(splist_UniqueSpecies$classification_path_ranks[s], "|", fixed=TRUE))
temp <- as.data.frame(cbind(paths, ranks))
if (length(which(temp$ranks=="superkingdom"))>0){
splist_UniqueSpecies$superkingdom[s] <- temp[which(temp$ranks=="superkingdom"), 1]
}
if (length(which(temp$ranks=="kingdom"))>0){
splist_UniqueSpecies$kingdom[s] <- temp[which(temp$ranks=="kingdom"), 1]
}
if (length(which(temp$ranks=="phylum"))>0){
splist_UniqueSpecies$phylum[s] <- temp[which(temp$ranks=="phylum"), 1]
}
if (length(which(temp$ranks=="class"))>0){
splist_UniqueSpecies$class[s] <- temp[which(temp$ranks=="class"), 1]
}
if (length(which(temp$ranks=="order"))>0){
splist_UniqueSpecies$order[s] <- temp[which(temp$ranks=="order"), 1]
}
if (length(which(temp$ranks=="family"))>0){
splist_UniqueSpecies$family[s] <- temp[which(temp$ranks=="family"), 1]
}
if (length(which(temp$ranks=="genus"))>0){
splist_UniqueSpecies$genus[s] <- temp[which(temp$ranks=="genus"), 1]
}
if (length(which(temp$ranks=="species"))>0){
splist_UniqueSpecies$species[s] <- temp[which(temp$ranks=="species"), 1]
}
rm(paths, ranks, temp)
s=s+1
}
beep(sound = "fanfare")
View(splist_UniqueSpecies)
superkingdoms <- unique(splist_UniqueSpecies$superkingdom)
eukaryota <- subset(splist_UniqueSpecies$superkingdom = "Eukaryota")
eukaryota <- subset(splist_UniqueSpecies$superkingdom == "Eukaryota")
?subset
eukaryota <- subset(splist, superkingdom == "Eukaryota")
eukaryota <- subset(splist_UniqueSpecies, superkingdom == "Eukaryota")
View(splist_UniqueGenusOnly)
# Save the splist_UniqueGenusOnly and splist_UniqueSpecies outputs
saveRDS(splist_UniqueGenusOnly, file = "C:\\Users\\bydav\\Desktop\\SpList_GenusOnly.RDS")
saveRDS(splist_UniqueSpecies, file = "C:\\Users\\bydav\\Desktop\\SpList_Species.RDS")
sp_unID <- setdiff(speciesqc$SpeciesBinomial, splist_UniqueSpecies$user_supplied_name)
g_unID <- setdiff(speciesqc$SpeciesBinomial, splist_UniqueGenusOnly$user_supplied_name)
unID_names <- rbind(g_unID, spunID)
unID_names <- rbind(g_unID, sp_unID)
View(unID_names)
sp_unID
saveRDS(sp_unID, file = "C:\\Users\\bydav\\Desktop\\Unidentified_Species.RDS")
join_test <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "all",
unmatched = "drop",
relationship = "NULL"
)
Merge back the source metadata.
oin_test <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "all",
unmatched = "drop",
relationship = "one-to-one"
)
join_test <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "all",
unmatched = "drop",
relationship = "many-to-one"
)
View(splist_UniqueSpecies)
View(speciesqc)
join_test <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "first",
unmatched = "drop",
relationship = "many-to-many"
)
View(join_test)
join_test2 <- join_test <- inner_join(
speciesqc,
splist_UniqueSpecies,
by = join_by(SpeciesBinomial == user_supplied_name),
na_matches = c("never"),
multiple = "first",
unmatched = "drop",
relationship = "many-to-many"
)
# Add source info to the GNR_resolved names
SpList_wSource <- inner_join(
splist_UniqueSpecies,
speciesqc,
by = join_by(user_supplied_name == SpeciesBinomial),
na_matches = c("never"),
multiple = "first",
unmatched = "drop",
relationship = "many-to-many"
)
View(SpList_wSource)
# Remove fungi but not bacteria
nofungusamongus <- subset(SpList_wSource, kingdom == "Fungi")
# Save output without fungi
saveRDS(nofungusamongus, file = "C:\\Users\\bydav\\Desktop\\NoFungusSpeciesList.RDS")
# Remove bacteria but not fungi
eukaryota <- subset(SpList_wSource, superkingdom == "Eukaryota")
# Save output without bacteria
saveRDS(eukaryota, file = "C:\\Users\\bydav\\Desktop\\EukaryotaList.RDS")
# Remove fungi but not bacteria
nofungusamongus <- subset(SpList_wSource, kingdom == "Fungi")
# Save output without fungi
saveRDS(nofungusamongus, file = "C:\\Users\\bydav\\Desktop\\NoFungusSpeciesList.RDS")
# Remove bacteria and not fungi
clean_eukaryota <- subset(eukaryota, kingdom == "Fungi")
# Save output without bacteria
saveRDS(clean_eukaryota, file = "C:\\Users\\bydav\\Desktop\\MaineEukaryota_NoFungus.RDS")
# check what csv looks like
write.csv(clean_eukaryota, "C:\\Users\\bydav\\Desktop\\MaineEukaryota_NoFungus.csv")
# Remove fungi but not bacteria
nofungusamongus <- subset(SpList_wSource, kingdom != "Fungi")
# Save output without fungi
saveRDS(nofungusamongus, file = "C:\\Users\\bydav\\Desktop\\NoFungusSpeciesList.RDS")
# Remove bacteria and not fungi
clean_eukaryota <- subset(eukaryota, kingdom != "Fungi")
# Save output without bacteria
saveRDS(clean_eukaryota, file = "C:\\Users\\bydav\\Desktop\\MaineEukaryota_NoFungus.RDS")
View(clean_eukaryota)
MaineEukaryota_NoFungus <- readRDS("C:/Users/bydav/Desktop/MaineEukaryota_NoFungus.RDS")
# Save output without bacteria
saveRDS(eukaryota, file = "C:\\Users\\bydav\\Desktop\\GNREukaryotaList.RDS")
saveRDS(nofungusamongus, file = "C:\\Users\\bydav\\Desktop\\GNRNoFungusSpeciesList.RDS")
# Save output without bacteria
saveRDS(clean_eukaryota, file = "C:\\Users\\bydav\\Desktop\\GNREukaryota_NoFungus.RDS")
# Set a working path where files are and outputs go (can be separate)
path <- "C:/Users/bydav/Desktop/SpeciesList_Cleaning2024/"
tesload <- read.csv(path, "SpeciesListMeta.csv")
library(beepr) # to notify when long chunks are done
library(dplyr) # for cleaning
library(tidyverse) # for cleaning
library(taxize) # for taxonomy
library(rotl) # for taxonomy
library(stringi) # for cleaning
??gnr_resolve
gnr_datasources()
sources <- gnr_datasources()
View(sources)
