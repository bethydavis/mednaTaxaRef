taxonomies_orderseqs <- taxizedb::classification(order_seqs$species_id, db="ncbi") #get full taxonomies for each species selected to represent missing orders, output is a list-like "classification" object that sucks
#now loop through the sucky classification object to populate the empty dataframe
for (u in 1:length(taxonomies_orderseqs)) {
x <- as.data.frame(taxonomies_orderseqs[u])
if (dim(x)[1]>1) {
c4 <- paste0(x[which(x[,2]=="family"),c(1,3)], collapse="_")
c5 <- paste0(x[which(x[,2]=="genus"),c(1,3)], collapse="_")
c6 <- paste0(x[which(x[,2]=="species"),c(1,3)][1,], collapse="_")
}
if (exists("c4")){
if (length(c4) > 0) {
order_seqs$family[u] <- c4
} else {
order_seqs$family[u] <- NA
}
if (exists("c5")){
if (length(c5) > 0) {
order_seqs$genus[u] <- c5
} else {
order_seqs$genus[u] <- NA
}
if (exists("c6")){
if (length(c6) > 0) {
order_seqs$species[u] <- c6
} else {
order_seqs$species[u] <- NA
}
suppressWarnings(rm(list = c("x", "tax_query", "c4","c5","c6")))
}
order_seqs$search_name <- data.frame(do.call(rbind, strsplit(order_seqs$species, split = "_")))[,1]
#now loop through the sucky classification object to populate the empty dataframe
for (u in 1:length(taxonomies_orderseqs)) {
x <- as.data.frame(taxonomies_orderseqs[u])
if (dim(x)[1]>1) {
c4 <- paste0(x[which(x[,2]=="family"),c(1,3)], collapse="_")
c5 <- paste0(x[which(x[,2]=="genus"),c(1,3)], collapse="_")
c6 <- paste0(x[which(x[,2]=="species"),c(1,3)][1,], collapse="_")
}
if (exists("c4")){
if (length(c4) > 0) {
order_seqs$family[u] <- c4
} else {
order_seqs$family[u] <- NA
}
if (exists("c5")){
if (length(c5) > 0) {
order_seqs$genus[u] <- c5
} else {
order_seqs$genus[u] <- NA
}
if (exists("c6")){
if (length(c6) > 0) {
order_seqs$species[u] <- c6
} else {
order_seqs$species[u] <- NA
}
suppressWarnings(rm(list = c("x", "tax_query", "c4","c5","c6")))
}
x
m = 1
a02_REFDB <- data.frame(seq_header=NA, sequence=NA, seq_accession=NA, type=NA, species=NA) #create reference database skeleton
while (m <= dim(specieslist)[1]) { #for every good species name
cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
mito_ids <- "NA"
#if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
# } #else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
#mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
#}
if (is.na(mito_ids[1]) == FALSE) { #if there are mitogenome ids for species m
mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) #ask ENTREZ for id's accession
if (class(mito_accessions) != "try-catch"){ #if no api error
mito_accessions <- unlist(strsplit(mito_accessions, split="\n")) #format accession numbers
for (n in 1:length(mito_accessions)){ # loop through and scrape each mitogenome accession
new_row <- c(paste("Unparsed mitochondrion", mito_accessions[n], sep=" "), "na", mito_accessions[n], "scrape", species=specieslist$matched_name2[m]) #blank row for each accession
gb <- tryCatch(readGenBank(GBAccession(mito_accessions[n]))) # get the Genbank annotation for accession
if (class(gb) != "try-catch"){ #if no error in getting gb
if (is_mtgene==FALSE) {# if target locus is not a gene, look in otherFeatures()
target_feature <- tryCatch(which(otherFeatures(gb)$product %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(otherFeatures(gb)@ranges[target_feature]) #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
else if (is_mtgene==TRUE){ # if target locus is a gene, look in gene()
target_feature <- tryCatch(which(genes(gb)$gene %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(genes(gb)@ranges[target_feature])  #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
a02_REFDB <- rbind(a02_REFDB, new_row) # update the database
rm(gb, target_feature, target_range, target_seq, scraped_seq, new_row) # reset n loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close n loop (each "n" mitogenome accession per "m" species)
}
m=m+1 #update species m variable
rm(mito_ids, mito_accessions) # reset loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close for each species m loop
cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
mito_ids <- "NA"
#if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
# } else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) #ask ENTREZ for id's accession
while (m <= dim(specieslist)[1]) { #for every good species name
cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
mito_ids <- "NA"
if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
} else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
}
if (is.na(mito_ids[1]) == FALSE) { #if there are mitogenome ids for species m
mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) #ask ENTREZ for id's accession
if (class(mito_accessions) != "try-catch"){ #if no api error
mito_accessions <- unlist(strsplit(mito_accessions, split="\n")) #format accession numbers
for (n in 1:length(mito_accessions)){ # loop through and scrape each mitogenome accession
new_row <- c(paste("Unparsed mitochondrion", mito_accessions[n], sep=" "), "na", mito_accessions[n], "scrape", species=specieslist$matched_name2[m]) #blank row for each accession
gb <- tryCatch(readGenBank(GBAccession(mito_accessions[n]))) # get the Genbank annotation for accession
if (class(gb) != "try-catch"){ #if no error in getting gb
if (is_mtgene==FALSE) {# if target locus is not a gene, look in otherFeatures()
target_feature <- tryCatch(which(otherFeatures(gb)$product %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(otherFeatures(gb)@ranges[target_feature]) #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
else if (is_mtgene==TRUE){ # if target locus is a gene, look in gene()
target_feature <- tryCatch(which(genes(gb)$gene %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(genes(gb)@ranges[target_feature])  #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
a02_REFDB <- rbind(a02_REFDB, new_row) # update the database
rm(gb, target_feature, target_range, target_seq, scraped_seq, new_row) # reset n loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close n loop (each "n" mitogenome accession per "m" species)
}
m=m+1 #update species m variable
rm(mito_ids, mito_accessions) # reset loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close for each species m loop
if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
} else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
}
if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
} else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
}
if (specieslist$n_mitogenome[[m]]>0 && specieslist$n_mitogenome[[m]]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
} else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
}
while (s <= dim(specieslist)[1]){ #for every good species name
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) { # scrape GenBank target sequences if available, but skip if >= 100 targets
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
} else if  (specieslist$n_target[s]>100) {   # if more than 200 accessions, randomly select 100
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
if (ids[1] !="na"){ # if there are accessions, fetch them from GenBank
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta")))) # formatting - write out the sequences
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta") #formatting - read them back in as fasta
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc") # get accession numbers
seq_header <- names(fasta_target) #formatting
sequence <- paste(fasta_target) #formatting
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n")) # formatting
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s]) # make a temporary database with all sequences, their header, accession number, etc.
a02_REFDB <- rbind(a02_REFDB, tempDB) # append temporary database to the full database
}
s=s+1
}
#reset loop variables
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
#slow down request to the Entrez server or you'll get kicked out
Sys.sleep(1)
}
View(a02_REFDB)
s = 18
while (s <= dim(specieslist)[1]){ #for every good species name
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) { # scrape GenBank target sequences if available, but skip if >= 100 targets
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
} else if  (specieslist$n_target[s]>100) {   # if more than 200 accessions, randomly select 100
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
if (ids[1] !="na"){ # if there are accessions, fetch them from GenBank
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta")))) # formatting - write out the sequences
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta") #formatting - read them back in as fasta
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc") # get accession numbers
seq_header <- names(fasta_target) #formatting
sequence <- paste(fasta_target) #formatting
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n")) # formatting
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s]) # make a temporary database with all sequences, their header, accession number, etc.
a02_REFDB <- rbind(a02_REFDB, tempDB) # append temporary database to the full database
}
s=s+1
}
#reset loop variables
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
#slow down request to the Entrez server or you'll get kicked out
Sys.sleep(1)
}
m = 365
while (m <= dim(specieslist)[1]) { #for every good species name
cat("\r","scraping mitogenomes for species", m, "of", dim(specieslist)[1])
mito_ids <- "NA"
if (specieslist$n_mitogenome[m]>0 && specieslist$n_mitogenome[m]<20) { #if mitogenomes available and <20
mito_ids <- unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")) #format ids
} else if (specieslist$n_mitogenome[m]>20) { #if >20 mitogenomes, subsample 20 mitogenomes randomly
mito_ids <- sample(unlist(strsplit(specieslist$ids_mitogenome[m], split="\\|")),20) # format ids
}
if (is.na(mito_ids[1]) == FALSE) { #if there are mitogenome ids for species m
mito_accessions <- tryCatch(entrez_fetch(mito_ids, db="nuccore", rettype="acc")) #ask ENTREZ for id's accession
if (class(mito_accessions) != "try-catch"){ #if no api error
mito_accessions <- unlist(strsplit(mito_accessions, split="\n")) #format accession numbers
for (n in 1:length(mito_accessions)){ # loop through and scrape each mitogenome accession
new_row <- c(paste("Unparsed mitochondrion", mito_accessions[n], sep=" "), "na", mito_accessions[n], "scrape", species=specieslist$matched_name2[m]) #blank row for each accession
gb <- tryCatch(readGenBank(GBAccession(mito_accessions[n]))) # get the Genbank annotation for accession
if (class(gb) != "try-catch"){ #if no error in getting gb
if (is_mtgene==FALSE) {# if target locus is not a gene, look in otherFeatures()
target_feature <- tryCatch(which(otherFeatures(gb)$product %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(otherFeatures(gb)@ranges[target_feature]) #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
else if (is_mtgene==TRUE){ # if target locus is a gene, look in gene()
target_feature <- tryCatch(which(genes(gb)$gene %in% as.character(target_locus_synonyms$Name))) # find target locus annotation metadata
if (class(target_feature) != "try-catch"){
if(length(target_feature) > 0) { # if target feature is found
target_range <- tryCatch(genes(gb)@ranges[target_feature])  #extract the target range info
if(class(target_range) != "try-catch"){
target_seq <- tryCatch(subseq(getSeq(gb), start=target_range@start, width=target_range@width)) #scrape seq
if(class(target_seq) != "try-catch"){
scraped_seq <- paste(target_seq) #format
new_row <- c(paste(names(target_seq),"mitochondrion", mito_accessions[n], sep=" "), paste(target_seq), mito_accessions[n], "scrape", specieslist$matched_name2[m]) #update information
}
a02_REFDB <- rbind(a02_REFDB, new_row) # update the database
rm(gb, target_feature, target_range, target_seq, scraped_seq, new_row) # reset n loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close n loop (each "n" mitogenome accession per "m" species)
}
m=m+1 #update species m variable
rm(mito_ids, mito_accessions) # reset loop variables
Sys.sleep(0.5) #slow down request to the Entrez server or you'll get kicked out
} # close for each species m loop
s = 365
while (s <= dim(specieslist)[1]){
# Display which species the script is on
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
# Scrape GenBank target sequences if available, but skip if >= 100 targets
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) {
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
# If more than 200 accessions, randomly select 100
} else if  (specieslist$n_target[s]>100) {
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
# If there are accessions, fetch them from GenBank
if (ids[1] !="na"){
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
# Format and write out the sequences
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))))
# Read the sequences back in as fasta files
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta")
# Get accession numbers
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc")
# Fix formatting of columns
seq_header <- names(fasta_target)
sequence <- paste(fasta_target)
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
# Make a temporary database with all sequences for the species, their header, accession number, etc.
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s])
# Append temporary database to the full database
a02_REFDB <- rbind(a02_REFDB, tempDB)
}
s=s+1 # Advance counter, then reset loop variables
}
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
# Slow request
Sys.sleep(1)
}
View(specieslist)
View(a02_REFDB)
while (s <= dim(specieslist)[1]){
# Display which species the script is on
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
# Scrape GenBank target sequences if available, but skip if >= 100 targets
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) {
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
# If more than 200 accessions, randomly select 100
} else if  (specieslist$n_target[s]>100) {
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
# If there are accessions, fetch them from GenBank
if (ids[1] !="na"){
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
# Format and write out the sequences
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))))
# Read the sequences back in as fasta files
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta")
# Get accession numbers
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc")
# Fix formatting of columns
seq_header <- names(fasta_target)
sequence <- paste(fasta_target)
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
# Set lengths equal so any empty spaces will fill with NAs
length(seq_header) <- length(sequence)
length(seq_accession) <- length(sequence)
# Make a temporary database with all sequences for the species, their header, accession number, etc.
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s])
# Append temporary database to the full database
a02_REFDB <- rbind(a02_REFDB, tempDB)
}
s=s+1 # Advance counter, then reset loop variables
}
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
# Slow request
Sys.sleep(1)
}
View(a02_REFDB)
s = 378
while (s <= dim(specieslist)[1]){
# Display which species the script is on
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
# Scrape GenBank target sequences if available, but skip if >= 100 targets
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) {
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
# If more than 200 accessions, randomly select 100
} else if  (specieslist$n_target[s]>100) {
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
# If there are accessions, fetch them from GenBank
if (ids[1] !="na"){
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
# Format and write out the sequences
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))))
# Read the sequences back in as fasta files
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta")
# Get accession numbers
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc")
# Fix formatting of columns
seq_header <- names(fasta_target)
sequence <- paste(fasta_target)
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
# Set lengths equal so any empty spaces will fill with NAs
length(seq_header) <- length(sequence)
length(seq_accession) <- length(sequence)
# Make a temporary database with all sequences for the species, their header, accession number, etc.
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s])
# Append temporary database to the full database
a02_REFDB <- rbind(a02_REFDB, tempDB)
}
s=s+1 # Advance counter, then reset loop variables
}
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
# Slow request
Sys.sleep(1)
}
s = 4573
while (s <= dim(specieslist)[1]){
# Display which species the script is on
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
# Scrape GenBank target sequences if available, but skip if >= 100 targets
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) {
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
# If more than 200 accessions, randomly select 100
} else if  (specieslist$n_target[s]>100) {
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
# If there are accessions, fetch them from GenBank
if (ids[1] !="na"){
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
# Format and write out the sequences
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))))
# Read the sequences back in as fasta files
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta")
# Get accession numbers
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc")
# Fix formatting of columns
seq_header <- names(fasta_target)
sequence <- paste(fasta_target)
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
# Set lengths equal so any empty spaces will fill with NAs
length(seq_header) <- length(sequence)
length(seq_accession) <- length(sequence)
# Make a temporary database with all sequences for the species, their header, accession number, etc.
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s])
# Append temporary database to the full database
a02_REFDB <- rbind(a02_REFDB, tempDB)
}
s=s+1 # Advance counter, then reset loop variables
}
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
# Slow request
Sys.sleep(1)
}
length(seq_header) <- length(sequence)
length(seq_accession) <- length(sequence)
while (s <= dim(specieslist)[1]){
# Display which species the script is on
cat("\r","scraping accessions for species", s, "of",dim(specieslist)[1])
ids <- "na"
seqs_target <- "na"
# Scrape GenBank target sequences if available, but skip if >= 100 targets
if (specieslist$n_target[s]>0 && specieslist$n_target[s]<100) {
ids <- c(unlist(strsplit(specieslist$ids_target[s], split="\\|")))
# If more than 200 accessions, randomly select 100
} else if  (specieslist$n_target[s]>100) {
ids <- sample(c(unlist(strsplit(specieslist$ids_target[s], split="\\|"))),100)
}
# If there are accessions, fetch them from GenBank
if (ids[1] !="na"){
seqs_target <- tryCatch(entrez_fetch(db="nuccore", id=ids, rettype="fasta"))
}
if(class(seqs_target) != "try-catch"){
if (seqs_target != "na"){
# Format and write out the sequences
write(seqs_target, file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))))
# Read the sequences back in as fasta files
fasta_target <- readDNAStringSet(file.path(path_outputs, paste(specieslist$matched_name2[s], paste0(locus, ".fasta"))), format="fasta")
# Get accession numbers
seqs_target_accessions <- entrez_fetch(db="nuccore", id=ids, rettype="acc")
# Fix formatting of columns
seq_header <- names(fasta_target)
sequence <- paste(fasta_target)
seq_accession <- unlist(strsplit(seqs_target_accessions, split="\n"))
# Set lengths equal so any empty spaces will fill with NAs
length(seq_header) <- length(sequence)
length(seq_accession) <- length(sequence)
# Make a temporary database with all sequences for the species, their header, accession number, etc.
tempDB <- data.frame(seq_header, sequence, seq_accession, type="accession", species=specieslist$matched_name2[s])
# Append temporary database to the full database
a02_REFDB <- rbind(a02_REFDB, tempDB)
}
s=s+1 # Advance counter, then reset loop variables
}
fasta_target<-"na"; seqs_target_accessions<-"na"; seq_header<-"na"; sequence<-"na"; seq_accession<-"na";
tempDB <-"na"
# Slow request
Sys.sleep(1)
}
write.csv(order_seqs, file.path(path_outputs, "StepG3Output.csv"), row.names=FALSE)
write.csv(a02_REFDB, file.path(path_outputs, "Incomplete_a02_REFDB.csv"), row.names=FALSE)
